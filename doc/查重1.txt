
书籍是承载着人类文明和智慧的载体，阅读自古以来一直是中华民族的优良传统。随着科学技术的飞速发展，智能的手机的大范围普及，手机阅读逐渐作为了一种全新的阅读方式走进人们的生活。本文介绍了一款基于WEB平台的阅读APP的设计与实现，该APP采用简洁护眼颜色搭配，简洁舒适的设计风格，集合了现有市场APP的众多功能，采用React、Redux、Webpack、Babel等最新的WEB开发技术，拥有流畅真实的翻书动画、自动记录阅读历史、多平台同步、收藏和分享图书等功能，同时支持智能分析用户阅读和搜索历史，并自动匹配、推荐用户可能喜爱的书籍，给用户一种全新的阅读体验。

中华民族是个有着优良的读书传统和悠久的读书历史的民族。上下五千年的历史长河中，文化典籍可以说是浩如烟海。古有悬梁刺股，凿壁借光，囊萤映雪之典故，近代有周总理“为中华之崛起而读书”的豪情，如今更有许许多多在读书人用成功诠释着读书的魅力。书籍是中华传统文化的载体，承载着中国人自古以来的精神追求。读万卷书，行万里路，读书不仅是一个人修养的一种标志，也是自我完善，自我提升，凝聚智慧的重要途径。勤于读书，善于读书，不仅能够增加你的知识储备，职业技能，还能提高你的精神气质，言谈举止之间透露出那种文雅脱俗，不卑不亢的境界。

目前，中国的经济实力已跃居世界前列，国家硬实力不断加强。但与之鲜明对比的是，中华文化的软实力确明显滞后。调查显示，我们国民阅读的整体已处于偏低水平，更多的出现功利读书的现象。读书，成了杀出重围获取高等学府的“入场券”，成了养家糊口“稻粮谋”的证书职称。现代人背负着生活重压，忙于考试，忙于工作，忙于挣钱，却忘了读书真正的意义。在全面实现小康社会的新时代，继承传统的读书文化，发扬中华民族的民族精神将会是我们面临的新的挑战。在发扬中国传统的读书文化，寻找新的读书方式的过程中，很多人把目光投向了智能手机。快节奏生活、碎片化阅读以及智能手机的普及，使用手机阅读渐渐成为主流，手机报、手机杂志、手机电子书等移动阅读方式也在慢慢融入人们的生活。这种方便，快捷，海量的读书方式也逐渐得到大家的认可。当然如今的手机阅读还存在着大量的问题，阅读的体验，长时间对身体的消耗，经典阅读微乎其微。数字化阅读方式使得泛读化、快餐化的浅阅读倾向呈现出“短、平、快”的阅读趋势，以丰富情趣、提高修养为目的的素质性阅读逐渐弱化，导致人们的阅读动机以休闲娱乐为主导，而文化传承、思想积淀呼唤的精读和深度阅读被大多数人摒弃。

在阅读数据采集上，该项目以传统文化为核心，更多的去承载经典的文学作品；在设计上，采用简洁的设计风格，给读者一种清新的阅读心境；在阅读方式上，项目给予用户更真实的读书体验，智能适应用户的读书习惯；在技术上，采用全新的WEB技术，实现了多平台同步使用，同步更新；在资源利用上，实现了按需加载，更多的从用户的角度考虑，节省内存，节省流量。这种全新的阅读体验将会为全民阅读的新时代贡献出不可或缺的力量。

Visual Studio Code是微软在Build
2015大会上发布的一款免费的现代化轻量级代码编辑器，支持了几乎所有主流开发语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比
Diff、Git等特性并支持插件扩展，支持Linux, OS X, and
Windows等多个平台，可以说是程序员的开发利器。

Visual Studio
Code对开发本项目所使用到的TypeScript和Go语言有很好的支持，可以在一个编辑器中通过编写和调试前后端的代码而无需安装多个IDE以及在多个IDE中切换，大大提高了开发效率。

2.2 TypeScript


TypeScript是由微软开发的开源的编程语言，它是JavaScript的超集，
并添加了可选的静态类型和基于类的面向对象编程。TypeScript完美的兼容了ES6，ES7的新特性，可编译成可读的，标准的JavaScript。TypeScript支持任意浏览器，任意环境，任意系统并且是开源的。

和JavaScript相比，Typescript编写的代码由于带有类型信息，更为健壮更具有可维护性。同时编辑器可以利用Typescript的类型信息提供更好的代码补全、代码检查、代码重构功能，有助于提供工作效率。

2.3 React


React，一个颠覆前端UI开发的框架。React是由Facebook开发的用于开发数据不断变化的大型应用程序的UI框架。React采用了Virtual
DOM的新思想，从根本上解决了频繁DOM操作的性能瓶颈问题。React采用组件化的构建思想，使用React，你唯一需要关心的就是编写组件，组件具有良好的封装性，可以简化代码的复用、测试和协作开发流程。基于组件的开发让项目内部组件可以很方便的复用，也可以很方便的从github等网站寻找第三方组件来满足自己需求，提高了代码重用率和开发效率。

本项目着重于手机端的使用，页面不重复刷新，流量的合理控制，代码的简洁重复使用成为了很重要的问题，选用React框架可以说几乎完美的解决这些问题。

2.4 Redux


Redux是Facebook
Flux架构的一种简化实现，它是前端数据的一个状态容器，提供了可预测的状态管理。Redux采用了reduce和纯函数的概念，每个新的state都是由旧的state在action的作用下生成的。state集中在单一树状对象上，即store，是整个项目的数据层。Redux通过这种数据管理方式解决了React数据处理比较混乱的问题。

Redux自带了非常优秀的调试工具，可以看到应用的历史状态和所有的状态变更，支持像视频播放器一样对应用的快进快退操作，支持代码热加载，修改代码的同时就可以看到新代码生效的结果，而无需重新打开应用，大大提高了前端开发效率。

本项目采用了Redux-Immutable的形式实现前端的数据管理，Immutable
内部使用了 Trie 数据结构来存储，
两个对象的区别取决去hashCode的值，这给React的性能带来的很大的提升。

2.5 Webpack+Gulp


Webpack
是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。Gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；它不仅能对网站资源进行优化，而且在开发过程中很多重复的任务，比如文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤能够使用正确的工具自动完成。Webpack和Gulp的结合，完美的发挥了各自的优点，大大的提升了前端项目的打包，开发体验。

2.6 Go语言


Go语言起源于2007年，2009年正式对外发布。Go语言语法灵活、简洁、清晰、高效，在快速编译，高效执行和易于开发之间找到了最佳平衡，它将静态语言的安全性和高效性与动态语言的易开发性进行了有机结合，使得既高效又实用成为可能。它的并发特性可以方便地用于多核处理器和网络开发，同时灵活新颖的类型系统可以方便地编写模块化的系统。Go语言可以快速编译，同时具有垃圾内存自动回收功能，并且还支持运行时反射，在多线程网络编程方面起到了不可替代的作用。

本项目在后端服务器搭建和API接口实现方面均使用Go语言实现，使得服务部署，开发效率方面都得到了明显的提高。

2.7 MongoDB


MongoDB是一个开源的，基于分布式文件存储的，高性能，无模式的数据库，它是使用C++编写的面向文档的数据库。MongoDB的模式是自由的，对于存储在数据库中的文件，我们无需关心它的任何结构定义。它以键值对的方式存储文档，通过唯一标示的键即可找到对应存储的文档信息。MongoDB
为WEB应用提供可扩展的高性能数据存储解决方案。

本项目数据结构不算太复杂，系统设计也相对简单，数据源都采用JSON格式，使用MongoDB这个数据库，可减少多余的数据转换的步骤，便于快速使用和操作数据，是实现系统的不二之选。

2.8 REST API


REST，Representational State
Transfer，表示资源在网络中的状态转移。REST的核心是资源，资源是以JSON为载体，面向用户的一组数据集。REST通过URL来定位资源，用HTTP协议的方法来对资源进行增删改查操作，统一了数据操作的接口，使仅通过HTTP方法就可以完成对所有数据的操作。随着近年来移动互联网的发展，客户端种类逐渐增加，前后端分离成为了迫切需求，RESTful
API使得Web端和Server统一魏永API来传递数据和改变数据状态成为可能。Web，iOS，Android和第三方开发者可通过一套API来共同消费Server提供的服务。    

本项目在需求分析之后拟定了一套RESTful规则，统一了对资源的操作流程，使得项目在开发过程中可以前后端同时进行，并解决了不同操作系统对于资源访问的兼容性问题。

需求分析 {#需求分析 .a0}


本章详细描述了本项目的详细需求，为整个项目开发和技术实现提供指南，同时确定项目的内容和范围，为评价和测试该项目提供依据。该项目客户端功能模块大致分为：登录注册模块、图书搜索模块、图书分类模块、图书阅读模块、图书收藏模块、图书分享模块、图书推荐模块、阅读历史查看模块。

下面将分别对于这些功能模块进行需求分析的详细说明。

3.1 客户端功能需求 {#客户端功能需求 .22}


客户端系统包含游客和会员两种角色，游客用户拥有基本的图书阅读权限，会员则包含很多会员专享权限。

**图3.1.1 系统角色图 图3.1.2 客户端系统用例图**


**图3.1.3 客户端系统用例分解图**

### 3.1.1 登录注册功能 {#登录注册功能 .af7}

为了方便用户的使用，数据同步等，软件需要登录注册，该模块设计的主要需求为：

（1）用户可以采用游客的方式试用软件，在没有登录时可以体验应用的部分功能。

（2）用户点击登录按钮，进入登录页面，用户可试用已经注册的账号密码登录，也可使用微信，微博，QQ等第三方应用账号登录。

（3）还没有账户的用户可点击注册按钮，进入注册页面进行注册，注册成功后，将自动登录。

（4）用户首次注册成功后，将进行阅读兴趣的选择，阅读方式的配置等，将用户的配置信息存储到服务器进行同步。

（5）用户可在user页面退出登录

### 3.1.2图书搜索功能 {#图书搜索功能 .af7}

用户可输入关键词进行图书搜索，该模块设计的主要需求为：

（1）用户进入主页可在页面中看到搜索栏。

（2）在搜索栏中输入关键词即可搜索想看的图书。

（3）根据用户的输入实时显示搜索结果。

### 3.1.3图书分类功能 {#图书分类功能 .af7}

用户可筛选特定类型的书籍，该模块设计的主要需求为：

（1）用户进入主页可看到图书的所有分类。

（2）点击类型，显示对应类型的图书列表，列表中包含图书名称及介绍信息。

（3）点击列表中图书，进入图书的详细介绍页。

### 3.1.4图书阅读功能 {#图书阅读功能 .af7}

用户可阅读选择的图书，该模块设计的主要需求为：

（1）用户点击图书详细介绍页的去读或者目录栏的特定章节，即可进入阅读模式。

（2）阅读模式主页显示对应章节的书的内容，并实现逼着的翻页动画。

（3）页面左下角显示目前的读书进度。

（4）页面的右下角显示当前时间和当前设备的电量，以及是否处于充电模式。

（5）单击页面中的任何位置，弹出设置页面。

（6）设置页面可设置屏幕亮度，字体大小，白天夜间模式等。

### 3.1.5图书收藏功能 {#图书收藏功能 .af7}

用户可对自己喜欢的书籍进行收藏，该模块设计的主要需求为：

（1）单击阅读页面,弹出收藏按钮。

（2）如果用户喜欢该书籍，可点击收藏按钮进行收藏，收藏按钮变为已收藏按钮。

（3）如果用户已经收藏可点击已收藏按钮，取消收藏。

（4）用户可进入收藏页面，查看自己已经收藏图书的图书列表。

### 3.1.6图书分享功能 {#图书分享功能 .af7}

用户可对自己喜欢的书籍进行分享，该模块设计的主要需求为：

（1）单击阅读页面,弹出分享按钮。

（2）如果用户喜欢该书籍，可点击分享按钮，弹出选择分享方式的页面。

（3）分享方式有朋友圈、qq空间、新浪微博、微信好友、qq好友。

（4）单击分享方式即可分享对应书籍。

### 3.1.7图书推荐功能 {#图书推荐功能 .af7}

服务器根据用户的兴趣和读书种类，给用户推荐其可能喜爱的图书，该模块设计的主要需求为：

（1）用户在进入收藏页面时，可在页面尾部看到系统推荐图书的图书列表。

（2）点击感兴趣的图书即可查看图书详细信息和阅读图书。

### 3.1.8阅读历史查看功能 {#阅读历史查看功能 .af7}

用户可查看自己的阅读历史，该模块设计的主要需求为：

（1）用户再次进入应用，应用会提醒用户是否回到上次阅读，用户点击是可直接进入上次阅读的页面。

（2）用户查看某本已经看过的书籍时，应用会提醒用户是否回到该书的上次阅读，用户点击是可直接进入该书的上次阅读的页面。

（3）用户可在User页面查看读过书的数量及近期读书的时间。

3.2 服务端功能需求 {#服务端功能需求 .22}


服务器端主要给客户端提供RESTful
API支持。下面针对具体服务进行需求上的详细说明。

![](media/image4.png){width="2.857720909886264in"
height="3.2863790463692037in"}

图3.2.1 服务端系统用例图

![](media/image5.png){width="5.768055555555556in" height="3.225in"}

图3.2.2 服务端系统用例分解图

-   **用户登录注册服务：**用户登录注册服务主要响应客户端传送过来的登录注册请求，将用户信息保存到数据库并返回成功登陆注册的提示信息，如果登录失败，则返回友好的错误信息。

-   **图书关键词查询服务：**图书关键词查询服务主要响应客户端的查询请求，通过参数的关键字词信息，在数据库中查找相关信息，并将信息返回给客户端。

-   **获取所有分类服务：**获取所有分类服务主要响应客户端获取所有分类的请求，将数据库中数据所有类型返回给客户端。

-   **获取当前分类图书列表服务：**获取当前分类图书列表服务主要响应客户端特定类型图书列表的请求，将数据库中属于该类型的图书列表返回给客户端。

-   **图书详细信息查询服务：**图书详细信息查询服务主要响应客户端获取特定图书详细信息的请求，将数据库中该书的介绍信息返回给客户端。

-   **用户阅读进度上传服务：**用户阅读进度上传服务主要响应客户端存储用户进度的请求，将用户阅读进度及历史的相关信息存储到数据库中。

-   **用户阅读进度查询服务：**用户阅读进度查询服务主要响应客户端获取用户阅读进度的请求，从数据库中读取用户最近阅读进度，返回给客户端。

-   **收藏图书服务：**用户阅读进度上传服务主要响应客户端添加或删除收藏图书的请求，将收藏的图书记录到用户收藏列表或者将该图书从收藏列表中删除。

-   **用户收藏图书查询服务：**用户收藏图书查询服务主要响应客户端获取用户收藏图书列表的请求，从数据库中获取用户收藏图书列表，返回给客户端。

-   **用户兴趣推荐服务：**用户兴趣推荐服务主要根据用户阅读历史，收藏数据等信息进行用户行为分析，生成推荐列表，向客户端推送。

3.3 性能需求 {#性能需求 .22}


（1）数据准确：图书信息，用户信息，用户收藏等API必须保证准确返回，保证良好的用户体验。

（2）响应时间：图书信息，用户信息，用户收藏等API保证在500ms之内返回。

（3）响应信息准确详细：用户请求API时尽可能返回详细的错误信息。

3.4 运行需求 {#运行需求 .22}


（1）客户端支持主流的Android手机，支持Android4.0以上、iOS 8以上系统。

（2）在用户没有网络或者网络极差的条件下，客户端需保证基本功能可以流畅使用。

数据库设计 {#数据库设计 .a0}


4.1数据库的需求分析 {#数据库的需求分析 .22}


通过对项目的需求分析，数据库数据存储的基本信息如下：

表4.1数据库存储信息表

  存储信息       字段
   
  图书分类信息   类型ID、类型名称、数目
  图书详细信息   图书ID、图书名称、图书作者、图书介绍、图书封面、图书章节列表（章节ID、章节名称）、图书分类
  图书内容       图书ID，章节ID，图书内容
  用户信息       用户ID、用户昵称、账号、密码、阅读详情（今日读书时间、累计读书时间、累计读书数目）
  收藏图书信息   用户ID，收藏图书列表（图书ID，分类标签）
  推荐图书信息   用户ID，推荐图书列表（图书ID）
  历史记录信息   用户ID，图书ID，章节ID，页数，历史创建时间

4.2 数据库的概念设计 {#数据库的概念设计 .22}


根据数据库需求分析，数据库应该包含八个主要的数据实体：

  数据库名称   字段
  
4.3 数据库的逻辑设计 {#数据库的逻辑设计 .22}


### 表4.3.1 Tag的逻辑设计表 {#表4.3.1-tag的逻辑设计表 .af7}

  序号   字段名     数据类型   
     
  1      tagId      string     主键
  2      category   string     
  3      booksCnt   number     

表4.3.1
描述图书类别信息的数据表，其中tagId为主键，category为类别名称，bookCnt为当前该类别所有图书的数量，每一次后端更新或者添加图书时，更新数据表。

### 表4.3.2 Book的逻辑设计表 {#表4.3.2-book的逻辑设计表 .af7}


表4.3.2
描述图书信息的数据表，其中bookId为主键，tagId为所属分类的外键，catalogue为该书所有章节的列表，书籍更新到数据库后信息基本不更新。

### 表4.3.3 Catalogue的逻辑设计表 {#表4.3.3-catalogue的逻辑设计表 .af7}

 
表4.3.3
描述章节具体信息的数据表。其中catalogueId为主键，chapter为章节标题。该数据为图书catalogueList的元素。

### 表4.3.4 Content的逻辑设计表 {#表4.3.4-content的逻辑设计表 .af7}

 表4.3.4
描述书籍详细内容的数据表。其中bookId，categoryId为主键。text为文章内容的数组，按段落分组。

### 表4.3.5 User的逻辑设计表 {#表4.3.5-user的逻辑设计表 .af7}


表4.3.5
描述用户详细信息的数据表。其中userId为主键，readStatus为用户历史阅读状态的统计，包括今日读书时间，累计读书时间和累计读书的数量，每日读书时间每晚24点清零。

### 表4.3.6 Collect的逻辑设计表 {#表4.3.6-collect的逻辑设计表 .af7}

表4.3.6
描述用户收藏列表的数据表，其中userId为主键，collectList为用户收藏图书列表，用户收藏图书时，会把图书对应的bookId存储到collectList中。

### 表4.3.7 Recommend的逻辑设计表 {#表4.3.7-recommend的逻辑设计表 .af7}

描述用户推荐列表的数据表，其中userId为主键，系统会定时进行用户行为分析，得出可能用户感兴趣的图书列表，将图书列表的id存储到recommendList中。

### 表4.3.8 History的逻辑设计表 {#表4.3.8-history的逻辑设计表 .af7}

表4.3.8
描述用户阅读历史的数据表。其中userId为主键，用户阅读图书时会不断上传当前读书的状态，将这些状态记录到该表中，用于分析用户行为和提醒用户快速回到上次阅读的状态。

详细设计 {#详细设计 .a0}


本章将在需求分析和数据库设计的基础上介绍该项目的详细设计过程。

5.1 后端API接口设计 {#后端api接口设计 .22}


后端API分为公共API和用户权限的API，用户权限API只有在用户登录成功之后才可发送成功，否则为无效请求。这种分离保证用户在没有登录或者以游客的身份进入应用时仍可正常使用该应用。下面对API的设计进行详细介绍。


5.2 前端架构设计 {#前端架构设计 .22}


 本项目前端采用React +
Redux + Immutable +
Webpack的组合开发框架，React用于构建前端个页面，即MVC的View层。Redux用于数据处理，实现了单项数据流，将项目中使用到的数据做集中化处理。Immutable完美的实现了不可变数据的流程，使数据在使用中不能被随便修改，也优化了React页面刷新机制中存在的一些问题。Webpack用于项目打包，将项目在生产环境和开发环境以不同的方式打包，将开发体验和用户体验都提升到最佳。

5.3 前端交互设计 {#前端交互设计 .22}


### 5.3.1 路由设计 {#路由设计 .af7}

**表5.3 项目路由设计表**
  

### 5.3.2主界面布局设计 {#主界面布局设计 .af7}

用户进入软件首先看到的是主界面模块。

主界面模块由四部分组成

（1）导航栏：左侧显示APP的图标，在页面任何地方点击该图标可回到应用主页，右侧为用户登录状态显示，如果用户没有登录，显示登录按钮，如果登录成功，显示用户昵称。点击登录按钮，即可进入登录页面，点击用户昵称可进入用户信息页面。

（2）
图书搜索框：图书全局搜索设计在页面内容的嘴上分，显眼的位置可以使用户使用更加方便。

（3）图书列表：接下来显示所有分类，及选中分类下的图书列表。分类采用显示一部分的方式，点击显示按钮，即可显示全部分类。点击感兴趣的分类，即可看到该分类下的图书列表。

（4）主菜单栏：书城、收藏，用户页面的切换按钮，方便用户在项目中快速找到自己需要的页面。


**图 5.3.1 主界面布局原型设计**

### 5.3.3 主界面交互设计 {#主界面交互设计 .af7}

用户进入应用时会自动获取用户最近一次阅读的状态，如果获取到用户阅读状态，会在页面下方提示用户是否回到上次阅读，如果用户选择继续阅读，可直接跳到上次阅读的位置。

**图5.3.2 主界面交互设计**

### 5.3.4图书列表布局设计 {#图书列表布局设计 .af7}

主页图书列表采用上下排列，具体图书信息采用图片加简要介绍的方式。上下精密排列可使用户在进入软件时尽可能看到多的图书，图片加介绍的方式更加形象的介绍了图书的基本信息，让用户在第一次看到图书时，对图书的理解已经了然于胸。

**图 5.3.3 图书列表布局原型设计**

### 5.3.5 搜索框设计 {#搜索框设计 .af7}

搜索框采用横向沾满整个屏幕的设计，让搜索功能更加醒目。搜索采用实时搜索，当用户输入关键字时自动发起搜索请求，并将搜索结果显示在搜索框下。

**图 5.3.4 搜索框原型设计**

### 5.3.6登录界面布局设计 {#登录界面布局设计 .af7}

用户点击登录按钮，即可进入登录页面。用户可采用已经注册的账号密码登录，也可使用社交账号直接登录。

### 5.3.7 登录界面交互设计 {#登录界面交互设计 .af7}

登录表单实现实时给用户提供错误信息，当输入框中输入的信息不符合对应的格式时，页面会随时提供给用户提示信息，直到用户输入正确，这样既可以减少请求次数，又可以提高用户体验。

**图 5.3.5 登录界面布局设计 图 5.3.6 登录界面交互设计**

### 5.3.8 注册页面布局设计 {#注册页面布局设计 .af7}

用户点击登录页面的还没有账户链接，即可进入注册页面。在注册页面，用户输入基本信息，并验证账户即可注册成功。注册页面也提醒用户可用社交账号直接登录，这样既不用填写表单，又不需要记忆多个账号密码，实用，方便。

**图 5.3.7 注册界面布局原型设计 图 5.3.8 注册界面交互设计**

### 5.3.9注册界面交互设计 {#注册界面交互设计 .af7}

注册表单也实现了实时给用户提供提示信息，同时在验证账户时，提供给用户倒计时发送验证码的方式，既减少用户多次
发送验证码造成服务器压力过大，又平和用户着急等待的心态。5.3.10图书详细介绍页布局设计

用户点击图书列表，即可进入图书详细页面。该页面分为三部分：

（1）图书基本信息：页面上部显示图书封面，作者，类型等信息以及一个醒目的去读按钮，如果用户迫不及待的想要看书的内容，点击去读即可进入阅读页面。

（2）图书简介：页面中间为该图书的简介，让用户简单了解该图书。

（3）图书目录：页面下部为图书目录页，用户可看到该图书的目录结构及标题，点击目录，即可进入对应目录的阅读页面，方便用户跳读。

### 5.3.11阅读图书布局设计 {#阅读图书布局设计 .af7}

用户点击去读获取目录即可进入阅读页面。

阅读页面由以下几部分组成

（1）标题：阅读页面的顶部为对应章节的标题，提醒用户当前所在的章节

（2）内容：中间为内容部分，显示书籍的详细信息

（3）信息展示：左侧为阅读进度，右侧为当前时间和设备的电量，如果设备处于充电模式，显示充电提醒。

**图 5.3.9 图书详细页面布局原型设计 图 5.3.10阅读图书页布局设计**

### 5.3.12 阅读图书页面交互设计 {#阅读图书页面交互设计 .af7}

阅读页面实现流畅的手势翻页，跟随动画等功能，提高用户体验。

单击页面中部，可进入阅读设置模式，可设置屏幕亮度，字体大小，白天夜间模式等，让用户阅读更加舒服。

如果用户喜欢可点击页面右上角的收藏按钮收藏图书，也可点击右上角的分享按钮分享图书。

**图 5.3.11阅读图书页交互设计 图 5.3.12分享布局设计**

### 5.3.13 收藏页面布局设计 {#收藏页面布局设计 .af7}

点击收藏按钮，即可进入收藏页面。

收藏页面采用封面显示书藏图书的方式。因为用户收藏图书，即用户已经充分了解该图书，不需要详细的图书介绍，只需通过封面，用户即可知图书信息。

点击图书可进入详细页面。

### 5.3.14 推荐页面布局设计 {#推荐页面布局设计 .af7}

收藏页面下方为推荐图书列表。

推荐图书同样采用了封面列表的方式，和收藏列表保持相同的布局风格。

**图 5.3.13收藏推荐图书布局设计 图 5.3.1 用户信息界面布局设计**

### 5.3.15 用户信息页布局设计 {#用户信息页布局设计 .af7}

点击‘我’按钮，即可进入用户信息页面。用户信息页面分为三个部分：

（1）基本用户信息：页面上部显示用户头像，用户昵称，用户等级等信息，以及用户累积读书历史的信息。

（2）用户喜欢阅读的类型：根据用户读书历史和读书习惯，列出用户喜欢读书的类型标签。

（3）用户喜欢的作者：根据用户读书历史和收藏列表，列出用户喜欢的作者。

点击右上角退出按钮，用户即可退出登录。

**\
**

系统实现 {#系统实现 .a0}


后端API接口的实现 {#后端api接口的实现 .22}


### 6.1.1公共API接口实现  {#公共api接口实现 .af7}

公共API接口实现基本流程为：

a.  获取用户请求参数信息；

b.  在数据库中查找相关数据；

c.  将数据进行格式化整理；

d.  将整理后的数据返回给用户。

下面将对具体API接口实现进行详细描述：

图6.1.1 公共API接口实现流程

### （1）获取图书所有分类的API实现 {#获取图书所有分类的api实现 .af7}

a\. 查找数据库中所有图书的类型；

b\. 将获取的数据进行格式化；

c\. 返回格式化后的数据。

### （2）获取特定分类下的图书列表的API实现 {#获取特定分类下的图书列表的api实现 .af7}

a\. 获取请求参数中tagId；

b\. 在数据库中查找该类型的图书；

c\. 将图书列表进行整理；

d\. 返回格式化后的图书列表。

### （3）获取特定图书的详细信息的API实现 {#获取特定图书的详细信息的api实现 .af7}

a\. 获取请求参数中的bookId；

b\. 在数据库中查找该图书；

c\. 将图书信息进行整理；

d\. 返回格式化后的图书信息。

### （4）获取图书特定章节的图书内容的API实现 {#获取图书特定章节的图书内容的api实现 .af7}

a\. 获取请求参数中的bookId 和 categoryId；

b\. 在数据库中找到对应图书；

c\. 在图书的章节列表中找到对应的章节；

d\. 获取对应章节的内容；

e\. 将内容信息进行整理；

f\. 返回整理后的图书内容。

### （5）获取特定关键词搜索图书列表的API实现 {#获取特定关键词搜索图书列表的api实现 .af7}

a\. 获取请求参数中用户查找的关键词；

b\. 在数据库中查找含有该关键词的图书；

c\. 将找到的图书按照出现的次数进行排序；

d\. 返回排序后的图书列表。

### 6.1.2 用户权限API接口设计 {#用户权限api接口设计-1 .af7}

### （1）注册的API实现 {#注册的api实现 .af7}

注册API的实现流程：

a.  获取用户注册参数信息；

b.  判断参数格式是否正确；

c.  如果参数格式错误，执行步骤d，否则，执行步骤e；

d.  返回参数格式错误提示信息；

e.  在数据库中查找该账户是否存在；

f.  如果该账户存在，执行步骤g，否则，执行步骤h；

g.  返回账户已经注册错误信息；

h.  将用户密码加密；

i.  将用户信息存入数据库；

j.  计算jwt；

k.  返回jwt。

图6.1.2 注册API接口实现流程图

### （2）登录的API实现 {#登录的api实现 .af7}

登录API的实现流程：

a.  获取用户登录参数信息；

b.  判断参数格式是否正确；

c.  如果不正确，执行步骤d，否则，执行步骤e；

d.  返回格式错误；

e.  在数据库查找该用户是否存在；

f.  如果用户不存在，执行步骤g，否则，执行h；

g.  返回用户不存在错误信息；

h.  将登录密码进行加密；

i.  判断加密后密码和数据库中密码是否相等；

j.  如果不相等，执行步骤k，否则，执行步骤l；

k.  返回密码错误提示信息；

l.  计算jwt；

m.  返回jwt。
图6.1.3 登录API接口实现流程图 图6.1.4
获取用户信息API接口实现流程图

### （3）获取用户信息的API实现 {#获取用户信息的api实现 .af7}

获取用户信息API实现流程：

a.  解析jwt，获取用户账户信息；

b.  在数据库中查找用户是否存在；

c.  如果不存在，执行步骤d，否则执行步骤e；

d.  返回用户不存在提示信息；

e.  整理用户信息；

f.  返回整理后数据。

### （4）收藏和取消收藏图书的API实现 {#收藏和取消收藏图书的api实现 .af7}

收藏和取消收藏图书API实现流程：

a.  解析jwt，获取用户账户信息；

b.  在数据库中查找用户是否存在；

c.  如果不存在，执行步骤d，否则执行步骤e；

d.  返回用户不存在提示信息；

e.  获取用户收藏bookId；

f.  在数据库中查找图书是否存在；

g.  如果图书不存在，执行步骤h，否则执行步骤i；

h.  返回图书不存在提示信息；

i.  判断用户操作是否为收藏；

j.  如果为收藏，执行步骤k，否则，执行步骤l；

k.  将bookId加入用户收藏列表；

l.  将bookId从用户收藏列表删除；

m.  返回操作成功。


图6.1.4收藏和取消收藏图书API接口实现流程图

### （5）获取收藏图书列表的API实现 {#获取收藏图书列表的api实现 .af7}

获取收藏图书列表API流程：

a.  解析jwt，获取用户账户信息；

b.  在数据库中查找用户是否存在；

c.  如果不存在，执行步骤d，否则执行步骤e；

d.  返回用户不存在提示信息；

e.  在数据库中查找用户收藏图书列表

f.  返回收藏列表

### （6）获取推荐图书列表的API实现 {#获取推荐图书列表的api实现 .af7}

获取推荐图书列表API流程：

a.  解析jwt，获取用户账户信息；

b.  在数据库中查找用户是否存在；

c.  如果不存在，执行步骤d，否则执行步骤e；

d.  返回用户不存在提示信息；

e.  在数据库中查找用户推荐图书列表

f.  返回推荐列表

### （7）上传用户读书记录的API实现 {#上传用户读书记录的api实现 .af7}

上传用户读书记录API流程：

a.  解析jwt，获取用户账户信息；

b.  在数据库中查找用户是否存在；

c.  如果不存在，执行步骤d，否则执行步骤e；

d.  返回用户不存在提示信息；

e.  在获取参数bookId

f.  在数据库中查找图书是否存在

g.  如果不存在，执行步骤h，否则，执行步骤i；

h.  返回图书不存在

i.  将读书信息和当前时间存入数据库

j.  返回操作成功

### （8）获取用户特定图书的最近记录的API实现 {#获取用户特定图书的最近记录的api实现 .af7}

获取用户特定图书历史记录API流程：

a.  解析jwt，获取用户账户信息；

b.  在数据库中查找用户是否存在；

c.  如果不存在，执行步骤d，否则执行步骤e；

d.  返回用户不存在提示信息；

e.  在获取参数bookId

f.  在数据库中查找图书是否存在

g.  如果不存在，执行步骤h，否则，执行步骤i；

h.  返回图书不存在

i.  查找数据库获取该图书最近一条历史记录

j.  返回操作成功

### （9）修改用户名的API实现 {#修改用户名的api实现 .af7}

修改用户名API流程：

a.  解析jwt，获取用户账户信息；

b.  在数据库中查找用户是否存在；

c.  如果不存在，执行步骤d，否则执行步骤e；

d.  返回用户不存在提示信息；

e.  获取参数nickName

f.  修改数据库中用户nickName

g.  返回操作成功

### （10）修改用户登录密码的API实现 {#修改用户登录密码的api实现 .af7}

修改用户登录密码API流程：

a.  解析jwt，获取用户账户信息；

b.  在数据库中查找用户是否存在；

c.  如果不存在，执行步骤d，否则执行步骤e；

d.  返回用户不存在提示信息；

e.  获取参数newPassword

f.  修改数据库中用户password

g.  返回操作成功

### （11）获取短信或邮箱验证码的API实现 {#获取短信或邮箱验证码的api实现 .af7}

获取短信或邮箱验证码API流程：

a.  解析jwt，获取用户账户信息；

b.  在数据库中查找用户是否存在；

c.  如果不存在，执行步骤d，否则执行步骤e；

d.  返回用户不存在提示信息；

e.  调用发送验证码服务

f.  给用户发送验证码，并将验证key返回客户端

图6.1.5 发送验证码API接口实现流程图

### （12）验证短信或邮箱验证码的API实现 {#验证短信或邮箱验证码的api实现 .af7}

验证短信或邮箱验证码API流程：

a.  解析jwt，获取用户账户信息；

b.  在数据库中查找用户是否存在；

c.  如果不存在，执行步骤d，否则执行步骤e；

d.  返回用户不存在提示信息；

e.  获取验证key和验证码

f.  验证key与验证码是否对应

g.  如果不对应，执行步骤h，否则，执行步骤i；

h.  返回验证码错误

i.  验证成功

图6.1.6 验证验证码API接口实现流程图

6.2前端组件的实现 {#前端组件的实现 .22}


### （1）Router组件的实现 {#router组件的实现 .af7}

定义了整个应用的路由，使用了react-router-redux组件。

图6.2.1 Router组件实现部分代码

### （2）Home组件的实现 {#home组件的实现 .af7}

Home组件为应用主页的基本架构，它是由Header、Footer、SearchInput
、CategoryList、RemindPopup组件组成的。

图6.2.2 Home组件实现部分代码

### （3）Header组件的实现 {#header组件的实现 .af7}

Header组件为整个项目的Header，实时更新用户登录状态，将其封装为单独的组件方便共用。

图6.2.3 Header组件实现部分代码

### （4）Footer组件的实现 {#footer组件的实现 .af7}

Footer组件为整个应用的主路由切换组件，放在页面醒目的位置方便用户使用，单独封装，可多个页面共用。

图6.2.4 Footer组件实现部分代码

### （5）SerchInput组件的实现 {#serchinput组件的实现 .af7}

SearchInput组件实现了用户搜索图书实时请求，实时响应的功能。

图6.2.5 SerchInput组件实现部分代码

### （6）CategoryList组件的实现 {#categorylist组件的实现 .af7}

CategoryList组件采用map的方式，将后端返回的图书类型一一展现在用户面前。

图6.2.6 CategoryList组件实现部分代码

### （7）RemindPopup组件的实现 {#remindpopup组件的实现 .af7}

RemindPopup主要实现获取用户的历史状态，及时提醒用户回到上一次阅读状态。

图6.2.7 RemindPopup组件实现部分代码

### （8）BookList组件的实现 {#booklist组件的实现 .af7}

BookList同样采用map的方式，将对应分类的图书列表展示给用户。

图6.2.8 BookList组件实现部分代码

### （9）Loading组件的实现 {#loading组件的实现 .af7}

Loading组件主要用户页面在请求API，没有返回数据的时候显示，用户提醒用户需要稍等片刻，提高用户体验。

图6.2.9 Loading组件实现部分代码

### （10）BookContent组件的实现 {#bookcontent组件的实现 .af7}

BookContent组件为阅读页面的布局，由header、footer、content组成。其中content是将文章内容安装当前设备大小进行布局，将页面逼真的显示在用户面前。

图6.2.10 BookContent组件实现部分代码

### （11）BookContentHeader组件的实现 {#bookcontentheader组件的实现 .af7}

BookContentHeader组件为当用户点击阅读页面时，缓缓展示给用户的header部分。实现了用户退出阅读模式，收藏和分享功能。


图6.2.11 BookContentHeader组件实现部分代码

### （12）BookContentFooter组件的实现 {#bookcontentfooter组件的实现 .af7}

BookContentFooter组件为用户阅读设置组件，实现了设置屏幕亮度，字体大小、白天夜间模式等。

图6.2.12 BookContentFooter组件实现部分代码

### （13）Share组件的实现 {#share组件的实现 .af7}

Share实现了当用户点击分享按钮时，提供可分享的平台按钮，供用户分享。

图6.2.13 Share组件实现部分代码

### （14）BookItem组件的实现 {#bookitem组件的实现 .af7}

BookItem组件实现了获取当前设备的尺寸推算当前文章的页数大小等功能，将数据传给需要该数据的组件用户界面的显示。且实现了设置屏幕亮度时对应页面的亮度变化。

图6.2.14 BookItem组件实现部分代码

### （15）FlipAnimation组件的实现 {#flipanimation组件的实现 .af7}

FlipAnimation组件完成了手势跟随的翻页动画的实现。通过touchStart，touchMove和touchEnd的方法计算移动点之间的距离和角度，从而页面做出相应的响应，给用户以逼真的体验。

图6.2.15 FlipAnimation组件实现部分代码

### （17）Battery组件的实现 {#battery组件的实现 .af7}

FlipAnimation通过读取用户当前设备的电量状态，让用户在阅读页面也能对当前设备的电量了如指掌。

图6.2.16 Battery组件实现部分代码

### （18）Article组件的实现 {#article组件的实现 .af7}

Article组件为图书介绍页详细信息的布局组件。

图6.2.17 Article组件实现部分代码

### （19）LoginForm组件的实现 {#loginform组件的实现 .af7}

LoginForm组件实现了登录的表单。采用Redux-Form的方式实现了实时提示用户输入信息。

图6.2.18 LoginForm组件实现部分代码

### （20）RegisterForm组件的实现 {#registerform组件的实现 .af7}

RegisterForm实现了注册表单，同样使用了Redux-Form的方式来提高用户体验。

图6.2.19 RegisterForm组件实现部分代码

### （21）Collection组件的实现 {#collection组件的实现 .af7}

Collection组件为收藏图书列表和推荐图书列表的布局实现已经用户没有登录状态下的提示信息的显示。

图6.2.20 Collection组件实现部分代码

### （22）User组件的实现 {#user组件的实现 .af7}

User组件用户展示用户基本信息，及用户感兴趣的类型等模块。

图6.2.21 User组件实现部分代码

 总结 {#总结 .a0}


本项目结合平时学习生活中手机阅读中所需要的一些必要功能，结合市场上阅读器的众多优点，也针对现有软件的一些不足，实现的一个基于WEB应用的多平台的手机阅读器。

项目开发过程中，主要使用Visual Studio
Code作为主要开发工具，采用Mongodb这个非关系数据库，使用Go语言实现访问数据库和处理后端逻辑，前端采用React+Redux+TypeScript开发框架，采用Webpack+Gulp作为前端打包工具。采用react-redux-router实现了页面跳转无刷新，Immutable完美实现了不可变数据。本地数据存储采用localStorage，用户信息存储使用cookie，降低了服务器的压力。使用React封装的touch事件和CSS3动画完美的实现了手势跟随翻页的复杂动画，并使用第三方登录、分享接口，实现了账号统一，基本社交功能的需求。

在项目的设计开发过程中，我充分的了解了软件设计开发过程中的设计思想和流程，分析了在学习生活中现有手机阅读器的众多优势和不足，并在学生群体中做了充分的调查。该项目的开发不仅实现了所需的必要功能，还优化了很多现有软件的不足。下面我将对我的项目特色做详细的介绍：

1.  精心挑选的颜色搭配及个性化的用户设置。

> 项目主界面采用浅橙色这种既不失重要提示作用，又给用户以舒服感觉的颜色，让用户在使用的过程中，保持愉悦的心情，迅速找到自己所需的书籍。阅读界面分白天、夜间两种模式，实现了在不同灯光下对眼睛的最大保护作用。用户还可以根据自己的阅读需求调节屏幕亮度、字体大小等，让阅读更加逼真，更加流畅。

1.  简洁舒服的界面设计。

> 项目的设计十分简洁，将重要功能，比如搜索、分类、菜单放置在页面最显眼的位置。阅读界面尽可能的实现仅包含阅读功能，这样能更好的让读者专心阅读，身临其境。

1.  流畅的翻书动画。

> 项目尽可能模拟现实物理现象实现动画，并针对手势做了多方面的细节处理，给用户以真实的阅读体验。

1.  第三方登录、分享的实现。

> 项目除了自身的登录功能之外，实现了第三方登录接口，用户可以使用自己常用的社交账号进行登录，减少登录注册的麻烦，方便用户更快、更好的使用。

1.  实时自动记录用户阅读历史。

> 用户在找书，阅读的过程中，应用会自动记录用户的查找、阅读历史，并在用户再次进入应用时智能提醒用户是否回到上次阅读的状态。

1.  完美的实现了多平台同步使用。

> 该应用实现了电脑、手机、平板多平台登录，并自动同步历史数据的功能，使得用户在不同的设备上使用有相同的体验。

1.  按需加载，节省流量。

> 流量的使用情况关系到用户是否放心使用该应用，所以这方面的优化也是必不可少的。在用户使用应用时，会获取用户当前的网络连接方式，如果是在数据流量的情况下，尽可能的减少图片加载，减少无关信息的加载等，在Wifi情况下，对用户最新访问的图书进行附近章节的缓存，以保证用户在无网络情况下仍可正常使用。

1.  智能推荐，为用户推荐可能想看的书籍。

> 项目会根据用户的阅读历史，阅读行为进行智能分析，并在数据库中匹配相应的书籍推荐给用户。

由于开发时间短，项目在细节处理方面还有很多不足，需要在接下来的学习生活中继续实践和完善。



经过三个多月的不懈努力，毕业设计即将告一段落了。总体来说，这次毕业设计还算是比较成功的。毕业设计的选题源自我的学习生活，初步设计的功能也都基本实现，包括细节和用户体验也做了多方面的处理。当然毕竟时间有限，加上自己的知识面也没有达到一定的宽度，项目的很多地方还是可以完善的，在今后的学习生活中，我会将该项目作为日常应用使用并不断的优化，争取做到可以上线的版本。

在这次毕业设计的过程中，我对大学四年所学的知识有了一个系统的认识，学习到了一个简单项目完成的不易。从产品设计到需求整理，再到真正的前后端分离的实现，还有一系列细节问题的处理，让我深感自己知识的欠缺，也激起了我继续学习的热情。

在这次毕业设计的过程中，我要特别感谢我的指导老师符琦老师，符琦老师是一位对学生，对工作认真负责的好老师。从大一开始，他就教给我们很多学习计算机的必备技能，从他的学习工作经历出发，给我们提供了更大的平台去学习技术。符琦老师对于新时代的新技术也一直充满激情，也一直鼓励我们除了书本知识，要去培养自己对于新技术的学习能力。在完成本次毕业设计的过程中，不管在选题方面，还是细节方面，都给了我很多建设性的建议，使我顺利完成了此次毕业设计。

我还要感谢李志刚老师，在我刚刚进入大学还很迷茫的时候，给了我很多方向上的建议，让我更加坚定的走技术这条路。

同时我还要感谢从大一开始就带我打比赛，一起讨论技术问题的王同学，在他的帮助下，我少走了很多技术弯路，让我能够在很短的时间内，学到更多的知识和技能。
